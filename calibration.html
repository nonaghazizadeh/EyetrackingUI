<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cognitive Eye-Tracking Experiment</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 2em;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #fafafa;
      text-align: center;
      overflow: hidden; /* Prevent scrollbars during calibration */
    }
    #mainContainer, #results {
      width: 80%;
      max-width: 800px;
    }
    #calibrationScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(255, 255, 255, 0.95);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #calibrationStatus {
      font-size: 24px;
      margin-bottom: 20px;
    }
    .calibrationPoint {
      position: absolute;
      width: 30px;
      height: 30px;
      background-color: red;
      border-radius: 50%;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .calibrationPoint:hover {
      background-color: darkred;
    }
    #taskContainer {
      font-size: 24px;
      line-height: 1.8em;
      min-height: 6em;
      padding: 1.5em;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      margin-bottom: 1.5em;
    }
    .question, .answer {
        text-align: left;
        word-break: break-word;
    }
    .question {
        font-weight: bold;
        color: #333;
        display: block;
        margin-bottom: 1.5em;
    }
    .answer {
        color: #555;
        display: block;
        font-weight: normal;
    }
    #status {
      font-size: 18px;
      color: #555;
      margin-bottom: 1em;
      line-height: 1.6;
      max-width: 600px;
    }
    #startButton {
      font-size: 20px;
      padding: 10px 20px;
      cursor: pointer;
    }
    #results { display: none; text-align: left; }
    #downloadLink {
      display: block;
      margin: 1em 0;
      font-size: 18px;
      padding: 12px;
      background-color: #007bff;
      color: white;
      text-align: center;
      text-decoration: none;
      border-radius: 5px;
    }
    #jsonData {
      width: 100%;
      height: 300px;
      font-family: monospace;
      font-size: 14px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <div id="calibrationScreen">
    <p id="calibrationStatus">Please wait for WebGazer to start...</p>
  </div>

  <div id="mainContainer">
    <div id="taskContainer"></div>
    <div id="status">
        <b>Instructions:</b> You are about to see a series of questions and answers. Each one will be displayed for about 12 seconds. Please read them to understand the logic.
    </div>
    <button id="startButton" disabled>Complete Calibration to Start</button>
  </div>
  
  <div id="results">
    <h2>Experiment Complete!</h2>
    <p>Thank you! Your gaze data has been analyzed and tagged.</p>
    <a href="#" id="downloadLink">Download tagged_results.json</a>
    <h3>Raw JSON Data</h3>
    <textarea id="jsonData" readonly></textarea>
  </div>

  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
  <script>
    const tasks = [
      {
        question: "A farmer has 17 sheep and all but 8 die. How many sheep are left?",
        answer: "The answer is 8. The phrase 'all but 8' directly states the number remaining."
      },
      {
        question: "What is the meaning of the sentence: The old man the boat?",
        answer: "The word 'man' is used as a verb, meaning to operate. The elderly are staffing the boat."
      },
      {
        question: "Data: Team A scored 20 points. Team B scored 40. Team C scored 30. Is the following statement true or false? Team B scored more than A and C combined.",
        answer: "False. Team A and C's combined score is 50, which is more than Team B's score of 40."
      }
    ];
    const DURATION_PER_TASK = 12000;

    const calibrationScreen = document.getElementById("calibrationScreen");
    const calibrationStatus = document.getElementById("calibrationStatus");
    const taskContainer = document.getElementById("taskContainer");
    const statusEl = document.getElementById("status");
    const startButton = document.getElementById("startButton");
    const mainContainer = document.getElementById("mainContainer");
    const resultsContainer = document.getElementById("results");

    let allResults = [];
    let currentTaskIndex = 0;
    
    let calibrationPoints = [
        [ '10%', '10%' ], [ '10%', '50%' ], [ '10%', '90%' ],
        [ '50%', '10%' ], [ '50%', '50%' ], [ '50%', '90%' ],
        [ '90%', '10%' ], [ '90%', '50%' ], [ '90%', '90%' ]
    ];
    let calibrationIndex = 0;

    function startCalibration() {
        calibrationStatus.innerHTML = `Please look at and click the red dot. Dot ${calibrationIndex + 1} of ${calibrationPoints.length}`;
        showCalibrationPoint();
    }

    function showCalibrationPoint() {
        const existingPoint = document.querySelector('.calibrationPoint');
        if (existingPoint) existingPoint.remove();

        if (calibrationIndex >= calibrationPoints.length) {
            endCalibration();
            return;
        }
        
        const [left, top] = calibrationPoints[calibrationIndex];
        const point = document.createElement('div');
        point.className = 'calibrationPoint';
        point.style.left = left;
        point.style.top = top;
        
        point.addEventListener('click', () => {
            point.style.backgroundColor = 'green';
            calibrationIndex++;
            calibrationStatus.innerHTML = `Please look at and click the red dot. Dot ${calibrationIndex + 1} of ${calibrationPoints.length}`;
            setTimeout(showCalibrationPoint, 500);
        });
        
        calibrationScreen.appendChild(point);
    }

    function endCalibration() {
        calibrationScreen.style.display = 'none';
        startButton.disabled = false;
        startButton.textContent = 'Start Experiment';
        statusEl.textContent = 'Calibration complete. You can now start the experiment.';
        webgazer.showVideoPreview(false).showPredictionPoints(false);
    }
    
    window.onload = async () => {
        mainContainer.style.visibility = 'hidden';
        await webgazer.setRegression("ridge").begin();
        webgazer.showVideoPreview(true).showPredictionPoints(false);
        webgazer.clearData();
        
        mainContainer.style.visibility = 'visible';
        startCalibration();
    };
    
    startButton.addEventListener("click", startExperiment);

    // Experiment state variables
    let gazeCounts = [], scanpath = [], wordSpans = [], allWords = [];
    let collecting = false;
    let currentWord = null, lastWord = null, dwellStart = 0;

    function startExperiment() {
        taskContainer.style.display = 'block';
        allResults = [];
        currentTaskIndex = 0;
        startButton.style.display = "none";
        statusEl.style.display = "none"; 
        showNextTask();
    }
    
    function showNextTask() {
      if (currentTaskIndex >= tasks.length) {
        displayFinalResults();
        return;
      }
      taskContainer.innerHTML = "";
      const task = tasks[currentTaskIndex];
      const questionText = `Question: ${task.question}`;
      const answerText = `Answer: ${task.answer}`;
      
      // Reset all state variables for the new task
      allWords = []; gazeCounts = []; scanpath = []; wordSpans = [];
      currentWord = null; lastWord = null;

      const qSpan = document.createElement('div');
      qSpan.className = 'question';
      questionText.split(/\s+/).forEach(word => {
          allWords.push(word);
          const span = document.createElement("span");
          span.textContent = word;
          qSpan.appendChild(span);
          qSpan.append(' ');
      });
      taskContainer.appendChild(qSpan);
      
      // We must re-populate wordSpans AFTER creating them in the DOM
      qSpan.querySelectorAll('span').forEach(span => wordSpans.push(span));

      const aSpan = document.createElement('div');
      aSpan.className = 'answer';
      answerText.split(/\s+/).forEach(word => {
          allWords.push(word);
          const span = document.createElement("span");
          span.textContent = word;
          aSpan.appendChild(span);
          aSpan.append(' ');
      });
      taskContainer.appendChild(aSpan);

      // We must re-populate wordSpans AFTER creating them in the DOM
      aSpan.querySelectorAll('span').forEach(span => wordSpans.push(span));
      
      gazeCounts = new Array(allWords.length).fill(0);
      
      // FIX: Set a fresh listener for each task to ensure it has the correct context
      webgazer.setGazeListener((data, elapsed) => {
        if (!data || !collecting) return;
        const { x, y } = data;
        let hitWordIndex = null;
        // The listener will now correctly use the wordSpans for the CURRENT task
        wordSpans.forEach((span, i) => {
            const rect = span.getBoundingClientRect();
            if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                hitWordIndex = i;
                gazeCounts[i]++;
            }
        });
        if (hitWordIndex !== null) {
            if (hitWordIndex !== currentWord) {
                currentWord = hitWordIndex;
                dwellStart = elapsed;
            } else {
                if (elapsed - dwellStart > 100) {
                    if (hitWordIndex !== lastWord) {
                        scanpath.push(hitWordIndex);
                        lastWord = hitWordIndex;
                    }
                }
            }
        }
      });

      collecting = true;
      setTimeout(processAndGoNext, DURATION_PER_TASK);
    }

    function processAndGoNext() {
      collecting = false; // Stop the listener from processing data
      const taggedWords = analyzeAndTagTrial(allWords, gazeCounts, scanpath);
      allResults.push({
        task: tasks[currentTaskIndex],
        tagged_words: taggedWords,
        scanpath_words: scanpath.map(i => allWords[i])
      });
      currentTaskIndex++;
      showNextTask();
    }

    function displayFinalResults() {
      webgazer.end();
      mainContainer.style.display = "none";
      resultsContainer.style.display = "block";
      const jsonString = JSON.stringify(allResults, null, 2);
      document.getElementById("jsonData").value = jsonString;
      const blob = new Blob([jsonString], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const downloadLink = document.getElementById("downloadLink");
      downloadLink.href = url;
      downloadlink.download = "tagged_results.json";
    }

    // --- Analysis Functions (Unchanged) ---
    const CONFIG = { think_more_gaze_count: 15, reevaluate_min_distance: 2, skip_step_min_distance: 5, parse_struggle_window: 5, parse_struggle_word_range: 4 };
    function analyzeAndTagTrial(allWords, gazeCounts, scanpath) {
        let tags = Array(allWords.length).fill(null).map(() => []);
        const answerStartIndex = allWords.indexOf("Answer:") > -1 ? allWords.indexOf("Answer:") : Math.floor(allWords.length / 2);
        tags = tagThinkMore(tags, gazeCounts);
        tags = tagRegressions(tags, scanpath, answerStartIndex);
        tags = tagSkipStep(tags, scanpath);
        tags = tagParseStruggle(tags, scanpath);
        tags = tagCommitAnswer(tags, scanpath, allWords.length);
        return allWords.map((word, i) => ({ word: word, gaze_count: gazeCounts[i], tags: [...new Set(tags[i])] }));
    }
    function tagThinkMore(tags, gazeCounts) { gazeCounts.forEach((c, i) => { if (c > CONFIG.think_more_gaze_count) tags[i].push("<think_more>"); }); return tags; }
    function tagRegressions(tags, scanpath, answerStartIndex) { for (let i = 1; i < scanpath.length; i++) { const o = scanpath[i - 1], d = scanpath[i]; if (d < o) { if (o >= answerStartIndex && d < answerStartIndex) { tags[o].push("<cross_reference>"); } else if (o - d >= CONFIG.reevaluate_min_distance) { tags[d].push("<re-evaluate>"); } } } return tags; }
    function tagSkipStep(tags, scanpath) { for (let i = 1; i < scanpath.length; i++) { const o = scanpath[i - 1], d = scanpath[i]; if (d - o > CONFIG.skip_step_min_distance) { for (let j = o + 1; j < d; j++) tags[j].push("<skip_step>"); } } return tags; }
    function tagParseStruggle(tags, scanpath) { const { parse_struggle_window: w, parse_struggle_word_range: r } = CONFIG; if (scanpath.length < w) return tags; for (let i = 0; i <= scanpath.length - w; i++) { const win = scanpath.slice(i, i + w); const min = Math.min(...win), max = Math.max(...win); if (max - min <= r) { if (win.some((v, j, a) => j > 0 && v < a[j - 1])) { for (let k = min; k <= max; k++) tags[k].push("<parse_struggle>"); } } } return tags; }
    function tagCommitAnswer(tags, scanpath, totalWords) { if (!scanpath || scanpath.length < 3) return tags; const last = scanpath.slice(-3); if (last.every(p => p >= totalWords - 5)) tags[scanpath[scanpath.length - 1]].push("<commit_answer>"); return tags; }

  </script>
</body>
</html>